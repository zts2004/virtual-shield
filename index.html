<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>虚境火盾 - 安全文件访问系统</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- 引入科幻字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <!-- 引入阿里云OSS SDK -->
    <script src="https://gosspublic.alicdn.com/aliyun-oss-sdk-6.17.1.min.js"></script>
    <!-- 引入OSS配置 -->
    <script src="assets/js/oss-config.js"></script>
</head>
<body>
    <!-- 背景Canvas -->
    <canvas id="bgCanvas"></canvas>

    <!-- 密码验证层 -->
    <div id="authLayer" class="auth-layer">
        <div class="auth-box">
            <h2>安全验证</h2>
            <input type="password" id="passwordInput" placeholder="请输入访问密码" maxlength="8">
            <button id="submitBtn">验证</button>
            <div id="errorMsg" class="error-msg"></div>
        </div>
    </div>

    <!-- 主要内容区 -->
    <div id="mainContent" class="main-content hidden">
        <h1 class="title">虚境火盾</h1>
        <div class="button-container">
            <button class="cyber-btn" data-path="附件一">附件一</button>
            <button class="cyber-btn" data-path="附件二">附件二</button>
            <button class="cyber-btn" data-path="附件三">附件三</button>
            <button class="cyber-btn" data-path="附件四">附件四</button>
            <button class="cyber-btn" data-path="视频">视频</button>
        </div>
    </div>

    <!-- 文件预览层 -->
    <div id="previewLayer" class="preview-layer hidden">
        <div class="preview-container">
            <div class="preview-header">
                <h3 id="previewTitle">文件预览</h3>
                <button id="closePreview" class="close-btn">关闭</button>
            </div>
            <div class="file-list" id="fileList"></div>
            <div class="preview-content" id="previewContent"></div>
        </div>
    </div>

    <script>
        // OSS客户端
        let ossClient = null;

        // 初始化OSS客户端
        function initOSSClient() {
            try {
                ossClient = new OSS({
                    region: ossConfig.region,
                    accessKeyId: ossConfig.accessKeyId,
                    accessKeySecret: ossConfig.accessKeySecret,
                    bucket: ossConfig.bucket,
                    endpoint: ossConfig.endpoint
                });
            } catch (error) {
                console.error('OSS初始化失败:', error);
            }
        }

        // 列出目录下的文件
        async function listFiles(prefix) {
            try {
                const result = await ossClient.list({
                    prefix: prefix,
                    delimiter: '/'
                });
                
                return result.objects || [];
            } catch (error) {
                console.error('获取文件列表失败:', error);
                return [];
            }
        }

        // 获取文件URL
        async function getFileUrl(objectName) {
            try {
                // 生成带签名的URL，有效期1小时
                const url = ossClient.signatureUrl(objectName, {
                    expires: 3600
                });
                return url;
            } catch (error) {
                console.error('获取文件URL失败:', error);
                return null;
            }
        }

        // 显示文件预览
        async function showFilePreview(path) {
            const files = await listFiles(path);
            const fileList = document.getElementById('fileList');
            const previewContent = document.getElementById('previewContent');
            
            // 清空文件列表
            fileList.innerHTML = '';
            previewContent.innerHTML = '';

            // 显示文件列表
            files.forEach(async file => {
                const fileName = file.name.split('/').pop();
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <span class="file-name">${fileName}</span>
                    <button class="preview-btn">预览</button>
                    <button class="download-btn">下载</button>
                `;

                // 添加预览事件
                fileItem.querySelector('.preview-btn').addEventListener('click', async () => {
                    const url = await getFileUrl(file.name);
                    if (url) {
                        showPreview(url, fileName);
                    }
                });

                // 添加下载事件
                fileItem.querySelector('.download-btn').addEventListener('click', async () => {
                    const url = await getFileUrl(file.name);
                    if (url) {
                        window.open(url);
                    }
                });

                fileList.appendChild(fileItem);
            });

            // 显示预览层
            document.getElementById('previewLayer').classList.remove('hidden');
        }

        // 显示预览内容
        function showPreview(url, fileName) {
            const previewContent = document.getElementById('previewContent');
            const ext = fileName.split('.').pop().toLowerCase();

            // 清空预览内容
            previewContent.innerHTML = '';

            // 根据文件类型显示不同的预览
            if (['jpg', 'jpeg', 'png', 'gif'].includes(ext)) {
                // 图片预览
                const img = document.createElement('img');
                img.src = url;
                img.className = 'preview-image';
                previewContent.appendChild(img);
            } else if (['mp4', 'webm'].includes(ext)) {
                // 视频预览
                const video = document.createElement('video');
                video.src = url;
                video.controls = true;
                video.className = 'preview-video';
                previewContent.appendChild(video);
            } else if (['pdf'].includes(ext)) {
                // PDF预览
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.className = 'preview-pdf';
                previewContent.appendChild(iframe);
            } else {
                // 其他文件类型
                const link = document.createElement('a');
                link.href = url;
                link.textContent = '点击下载文件';
                link.target = '_blank';
                previewContent.appendChild(link);
            }
        }

        // 密码验证相关变量
        let loginAttempts = 0;
        const MAX_ATTEMPTS = 3;
        const LOCK_TIME = 15000; // 15秒锁定时间
        let isLocked = false;

        // 获取当前日期密码
        function getCurrentPassword() {
            // 直接使用本地时间，因为系统时间应该已经是正确的
            const now = new Date();
            return now.getFullYear().toString() +
                   String(now.getMonth() + 1).padStart(2, '0') +
                   String(now.getDate()).padStart(2, '0');
        }

        // 验证密码
        function validatePassword(password) {
            const currentPassword = getCurrentPassword();
            console.log('当前密码：', currentPassword); // 添加调试信息
            const isValid = password === currentPassword;
            if (isValid) {
                // 保存当前验证通过的密码
                localStorage.setItem('lastPassword', currentPassword);
            }
            return isValid;
        }

        // 检查本地存储的验证状态
        function checkAuthStatus() {
            const authStatus = localStorage.getItem('authStatus');
            const authTime = localStorage.getItem('authTime');
            const lastPassword = localStorage.getItem('lastPassword');
            if (authStatus === 'true' && authTime && lastPassword) {
                const now = new Date().getTime();
                const authTimestamp = parseInt(authTime);
                // 验证状态24小时有效，且需要验证密码是否与当前日期匹配
                if (now - authTimestamp < 24 * 60 * 60 * 1000 && lastPassword === getCurrentPassword()) {
                    showMainContent();
                    return true;
                } else {
                    // 清除过期或无效的验证状态
                    localStorage.removeItem('authStatus');
                    localStorage.removeItem('authTime');
                    localStorage.removeItem('lastPassword');
                }
            }
            return false;
        }

        // 显示主内容
        function showMainContent() {
            document.getElementById('authLayer').style.display = 'none';
            document.getElementById('mainContent').classList.remove('hidden');
        }

        // 初始化事件监听
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化OSS客户端
            initOSSClient();

            // 检查验证状态
            if (!checkAuthStatus()) {
                document.getElementById('authLayer').style.display = 'flex';
            } else {
                showMainContent();
            }

            // 密码输入框事件
            const passwordInput = document.getElementById('passwordInput');
            const submitBtn = document.getElementById('submitBtn');
            const errorMsg = document.getElementById('errorMsg');

            submitBtn.addEventListener('click', () => {
                if (isLocked) {
                    errorMsg.textContent = `系统已锁定，请等待${Math.ceil((LOCK_TIME - (Date.now() - lockStartTime)) / 1000)}秒`;
                    return;
                }

                const password = passwordInput.value;
                if (validatePassword(password)) {
                    localStorage.setItem('authStatus', 'true');
                    localStorage.setItem('authTime', Date.now().toString());
                    showMainContent();
                } else {
                    loginAttempts++;
                    errorMsg.textContent = `密码错误，剩余尝试次数：${MAX_ATTEMPTS - loginAttempts}`;
                    
                    if (loginAttempts >= MAX_ATTEMPTS) {
                        isLocked = true;
                        const lockStartTime = Date.now();
                        errorMsg.textContent = `系统已锁定，请等待15秒`;
                        setTimeout(() => {
                            isLocked = false;
                            loginAttempts = 0;
                            errorMsg.textContent = '';
                        }, LOCK_TIME);
                    }
                }
            });

            // 文件按钮点击事件
            document.querySelectorAll('.cyber-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const path = btn.getAttribute('data-path');
                    showFilePreview(path);
                });
            });

            // 关闭预览按钮事件
            document.getElementById('closePreview').addEventListener('click', () => {
                document.getElementById('previewLayer').classList.add('hidden');
            });
        });

        // Canvas背景动画
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');

        // 设置Canvas尺寸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 粒子系统
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 1;
                this.speedX = Math.random() * 2 - 1;
                this.speedY = Math.random() * 2 - 1;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
                if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
            }

            draw() {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 创建粒子
        const particles = Array.from({ length: 100 }, () => new Particle());

        // 动画循环
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html> 